//! BattleActions::hitStepInvulnerabilityEvent - Check target invulnerability
//!
//! 1:1 port of hitStepInvulnerabilityEvent from battle-actions.ts

use crate::*;
use crate::battle_actions::ActiveMove;

/// Check if targets are invulnerable (e.g., Fly, Dig, etc.)
/// Equivalent to battle-actions.ts hitStepInvulnerabilityEvent()
///
/// hitStepInvulnerabilityEvent(targets: Pokemon[], pokemon: Pokemon, move: ActiveMove) {
///     if (move.id === 'helpinghand') return new Array(targets.length).fill(true);
///     const hitResults: boolean[] = [];
///     for (const [i, target] of targets.entries()) {
///         if (target.volatiles['commanding']) {
///             hitResults[i] = false;
///         } else if (this.battle.gen >= 8 && move.id === 'toxic' && pokemon.hasType('Poison')) {
///             hitResults[i] = true;
///         } else {
///             hitResults[i] = this.battle.runEvent('Invulnerability', target, pokemon, move);
///         }
///         if (hitResults[i] === false) {
///             if (move.smartTarget) {
///                 move.smartTarget = false;
///             } else {
///                 if (!move.spreadHit) this.battle.attrLastMove('[miss]');
///                 this.battle.add('-miss', pokemon, target);
///             }
///         }
///     }
///     return hitResults;
/// }
pub fn hit_step_invulnerability_event(
    battle: &mut Battle,
    targets: &[(usize, usize)],
    attacker_pos: (usize, usize),
    active_move: &mut ActiveMove,
) -> Vec<bool> {
    // if (move.id === 'helpinghand') return new Array(targets.length).fill(true);
    if active_move.id.as_str() == "helpinghand" {
        return vec![true; targets.len()];
    }

    //     const hitResults: boolean[] = [];
    let mut hit_results = Vec::new();

    //     for (const [i, target] of targets.entries()) {
    for &target_pos in targets {
        let hit_result = {
            // Get target pokemon to check volatiles and types
            let target_pokemon = match battle.pokemon_at(target_pos.0, target_pos.1) {
                Some(p) => p,
                None => {
                    hit_results.push(false);
                    continue;
                }
            };

            //         if (target.volatiles['commanding']) {
            //             hitResults[i] = false;
            if target_pokemon.volatiles.contains_key(&ID::from("commanding")) {
                false
            //         } else if (this.battle.gen >= 8 && move.id === 'toxic' && pokemon.hasType('Poison')) {
            //             hitResults[i] = true;
            } else if battle.gen >= 8 && active_move.id.as_str() == "toxic" {
                // Check if attacker has Poison type
                let attacker_has_poison = battle.pokemon_at(attacker_pos.0, attacker_pos.1)
                    .map(|p| p.has_type(battle, "Poison"))
                    .unwrap_or(false);
                attacker_has_poison
            //         } else {
            //             hitResults[i] = this.battle.runEvent('Invulnerability', target, pokemon, move);
            //         }
            } else {
                // runEvent returns Option<i32>, false = 0, true = non-zero or None
                let result = battle.run_event(
                    "Invulnerability",
                    Some(target_pos),
                    Some(attacker_pos),
                    Some(&active_move.id),
                    None,
                );
                result != Some(0) // true if not explicitly false
            }
        };

        hit_results.push(hit_result);

        //         if (hitResults[i] === false) {
        if !hit_result {
            //             if (move.smartTarget) {
            //                 move.smartTarget = false;
            //             } else {
            //                 if (!move.spreadHit) this.battle.attrLastMove('[miss]');
            //                 this.battle.add('-miss', pokemon, target);
            //             }
            if active_move.smart_target.unwrap_or(false) {
                active_move.smart_target = Some(false);
            } else {
                if !active_move.spread_hit {
                    battle.attr_last_move(&["[miss]"]);
                }
                // Add miss message
                if let (Some(attacker_pokemon), Some(target_pokemon)) = (
                    battle.pokemon_at(attacker_pos.0, attacker_pos.1),
                    battle.pokemon_at(target_pos.0, target_pos.1),
                ) {
                    let attacker_ident = format!("p{}a: {}", attacker_pos.0 + 1, attacker_pokemon.set.species);
                    let target_ident = format!("p{}a: {}", target_pos.0 + 1, target_pokemon.set.species);
                    battle.add("-miss", &[
                        crate::battle::Arg::String(attacker_ident),
                        crate::battle::Arg::String(target_ident),
                    ]);
                }
            }
        }
    }

    //     return hitResults;
    hit_results
}
