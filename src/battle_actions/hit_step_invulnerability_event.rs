use crate::*;

impl<'a> BattleActions<'a> {

    // =========================================================================
    // HIT STEP METHODS - Ported from battle-actions.ts
    // These are 1:1 ports of the hit step processing methods
    // =========================================================================

    /// Check invulnerability for targets
    /// Equivalent to hitStepInvulnerabilityEvent in battle-actions.ts
    // 	hitStepInvulnerabilityEvent(targets: Pokemon[], pokemon: Pokemon, move: ActiveMove) {
    // 		if (move.id === 'helpinghand') return new Array(targets.length).fill(true);
    // 		const hitResults: boolean[] = [];
    // 		for (const [i, target] of targets.entries()) {
    // 			if (target.volatiles['commanding']) {
    // 				hitResults[i] = false;
    // 			} else if (this.battle.gen >= 8 && move.id === 'toxic' && pokemon.hasType('Poison')) {
    // 				hitResults[i] = true;
    // 			} else {
    // 				hitResults[i] = this.battle.runEvent('Invulnerability', target, pokemon, move);
    // 			}
    // 			if (hitResults[i] === false) {
    // 				if (move.smartTarget) {
    // 					move.smartTarget = false;
    // 				} else {
    // 					if (!move.spreadHit) this.battle.attrLastMove('[miss]');
    // 					this.battle.add('-miss', pokemon, target);
    // 				}
    // 			}
    // 		}
    // 		return hitResults;
    // 	}
    //
    pub fn hit_step_invulnerability_event(
        targets: &[(usize, usize)],
        _attacker_flying: bool,
        _move_flags_contact: bool,
        _move_target: &str,
    ) -> Vec<(usize, usize, bool)> {
        // Returns (side_idx, pokemon_idx, is_hit)
        targets
            .iter()
            .map(|&(side_idx, pokemon_idx)| {
                // For now, all targets are hit unless in a semi-invulnerable state
                // Full implementation would check volatiles like Fly, Dig, Dive, etc.
                (side_idx, pokemon_idx, true)
            })
            .collect()
    }
}
